/***************************************************************************************************************************
 * This portion of the code originates from the Beremiz project, which is licensed under the GNU General Public License 
 * Version 2 (GPLv2). It has been temporarily incorporated into our current project, which is under the Apache License 
 * Version 2.0. We are aware of the licensing incompatibility between GPLv2 and Apache License Version 2.0 and are 
 * actively working on developing a more suitable solution tailored to our specific needs. This integration is 
 * provisional, and our goal is to replace this temporary implementation with our own, fully compliant version as soon 
 * as possible. We acknowledge the contribution of the MatIEC project and intend to ensure all uses are in line with 
 * its licensing terms during this transitional period. All users of this code are advised to consider the licensing 
 * implications of the GPLv3 and Apache License Version 2.0.
 ****************************************************************************************************************************/

/*
 * Generated by erpcgen 1.12.0 on Fri Mar 22 05:00:10 2024.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "c_erpc_PLCObject_client.h"
#include "erpc_PLCObject_client.hpp"
#include "erpc_manually_constructed.hpp"

using namespace erpc;
using namespace std;
using namespace erpcShim;


#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
BeremizPLCObjectService_client *s_BeremizPLCObjectService_client = nullptr;
#else
ERPC_MANUALLY_CONSTRUCTED_STATIC(BeremizPLCObjectService_client, s_BeremizPLCObjectService_client);
#endif

uint32_t AppendChunkToBlob(const binary_t * data, const binary_t * blobID, binary_t * newBlobID)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->AppendChunkToBlob(data, blobID, newBlobID);

    return result;
}

uint32_t GetLogMessage(uint8_t level, uint32_t msgID, log_message * message)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->GetLogMessage(level, msgID, message);

    return result;
}

uint32_t GetPLCID(PSKID * plcID)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->GetPLCID(plcID);

    return result;
}

uint32_t GetPLCstatus(PLCstatus * status)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->GetPLCstatus(status);

    return result;
}

uint32_t GetTraceVariables(uint32_t debugToken, TraceVariables * traces)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->GetTraceVariables(debugToken, traces);

    return result;
}

uint32_t MatchMD5(const char * MD5, bool * match)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->MatchMD5(MD5, match);

    return result;
}

uint32_t NewPLC(const char * md5sum, const binary_t * plcObjectBlobID, const list_extra_file_1_t * extrafiles, bool * success)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->NewPLC(md5sum, plcObjectBlobID, extrafiles, success);

    return result;
}

uint32_t PurgeBlobs(void)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->PurgeBlobs();

    return result;
}

uint32_t RepairPLC(void)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->RepairPLC();

    return result;
}

uint32_t ResetLogCount(void)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->ResetLogCount();

    return result;
}

uint32_t SeedBlob(const binary_t * seed, binary_t * blobID)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->SeedBlob(seed, blobID);

    return result;
}

uint32_t SetTraceVariablesList(const list_trace_order_1_t * orders, uint32_t * debugtoken)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->SetTraceVariablesList(orders, debugtoken);

    return result;
}

uint32_t StartPLC(void)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->StartPLC();

    return result;
}

uint32_t StopPLC(bool * success)
{
    uint32_t result;
    result = s_BeremizPLCObjectService_client->StopPLC(success);

    return result;
}

void initBeremizPLCObjectService_client(erpc_client_t client)
{
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
    erpc_assert(s_BeremizPLCObjectService_client == nullptr);
    s_BeremizPLCObjectService_client = new BeremizPLCObjectService_client(reinterpret_cast<ClientManager *>(client));
#else
    erpc_assert(!s_BeremizPLCObjectService_client.isUsed());
    s_BeremizPLCObjectService_client.construct(reinterpret_cast<ClientManager *>(client));
#endif
}

void deinitBeremizPLCObjectService_client(void)
{
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
    if (s_BeremizPLCObjectService_client != nullptr)
    {
        delete s_BeremizPLCObjectService_client;
        s_BeremizPLCObjectService_client = nullptr;
    }
#else
    s_BeremizPLCObjectService_client.destroy();
#endif
}
